## 9.7 静态变量、常量和方法

## 实例对象与静态变量的定义：

1. 实例变量-对象变量
	1. 指在数据域中没有被注明 static 的变量
	2. 实例变量不能被同一个类下的不同对象所共享
	3. 同类下的不同对象针对同一个实例变量做出的改变不互相影响
		* object1 中的 data 不会影响 object2 中的 data
	4. 如果想要同类下的所有对象共享数据域，就要使用static变量
	
	
2. 静态变量-类变量
	1. 静态变量可以被类下的所有对象共享
		* 共享意味着：改变值后相互影响
	2.	静态方法使用注意事项 
		1. 静态方法不能访问类下的任何对象
		2. 静态方法只能访问静态成员(成员=成员函数+成员变量)
		3. 非静态方法既可访问静态又可访问非静态
		4. 静态方法中不可以使用 this 和 super 关键字
		5. 主函数是静态的
			* 主函数只能调用 static 方法
			* 可以采用用“对象.方法”的形式来调用非静态方法
	3. 静态变量可以用来统计创建对象的个数
	
	
## 实例变量和静态变量的区别：

1. 变量声明周期不同
	1. 实例变量随着对象的创建而存在，随着对象的回收而释放
	2. 静态变量随着类的加载而存在，随着类的消失而消失
2. 调用方式不同
	1. 实例变量只能被对象调用
	2. 静态变量即可以被对象调用，又可以被类名调用
		* 不建议用对象调用static变量
3. 数据存储位置不同
	1. 成员变量存储在堆内存的对象中，也称对象的特有变量
	2. 静态变量存储在「方法区的静态区」下，也称对象的共享数据
4. 静态变量前省略的是“类名.”
5. 非静态变量前省略的是“this.”

## 什么时候用静态变量？
1. 静态变量
	1. 当对象中对于同一个成员变量的值都一样时，对象只需要访问，不需要修改，定义成静态的
	2. 若数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，定义成非静态的
	
2. 静态函数
	1. 该功能是否需要访问非静态的成员变量
		1. 需要：定义成非静态
		2. 不需要：定义成静态

## 静态代码块
```
	class ClassName
	{
		// 静态代码块
		static
		{
			System.out.println("the class is running");
		}
	}
```

1. 静态代码块没有函数名
2. 静态代码块写在类内
3. 静态代码块随着类的加载而执行
	* 而且只执行一次
4. 作用：用于对类进行初始化
	* 通常该类内全为静态成员
5. 静态代码块在主类中时，先执行静态代码块，再执行主函数

## 构造代码块
```
	class ClassName
	{
		// 构造代码块
		{
			System.out.println("object is running");
		}
	}
```

1. 写在类中的无名代码块称为构造代码块
2. 「构造代码块」是给所有对象进行初始化
3. 「构造函数」是给对应的对象进行针对性初始化
4. 构造代码块，每创建一个新对象执行一次
	* 构造代码块在构造函数前执行

## 局部代码块
```
	public void function()
	{
		// 函数代码块
		{
			System.out.println("funcition code area");
		}
	}
```

*  用于限制局部变量的生存周期


## 主函数是静态的：

1. 主函数`public static void main(String[] args)`
	1. 格式是固定的
		1. public : 权限必须是最大的
		2. static : 不需要“对象.”，直接用主函数所属类名调用即可
		3. void : 主函数没有具体的返回值
		4. main : 函数名，不是关键字，只是一个JVM识别的固定的名字
		5. String[] args : 一个数组类型的参数，元素都是字符串类型
			* Java虚拟机只识别参数()内的固定格式
			* 可以更改args名字
			* 不可更改String[] 类型
	2. 被JVM所识别和调用
	3. 虚拟机在调用主函数时给参数传递了一个"new String[0]"
	
## 成员变量和局部变量的区别：
1. 有效区域
	1. 成员变量定义在类中，整个类中都可以访问
	2. 局部变量定义在函数语句局部代码块中，只在所属的区域有效
2. 所在内存
	1. 成员变量存在于堆内存的对象中
	2. 局部变量存在于栈内存的方法中
3. 生命周期
	1. 成员变量随着对象的创建而出现，随着对象的消失而释放
	2. 局部变量随着所属区域的执行而存在，随着所属区域的结束而释放
4. 成员变量有默认初始化值，局部变量没有默认初始化值

## 当局部变量与成员变量同名时:
1. 局部变量的值会覆盖成员变量的值
2. 当方法在栈内运行时，由于局部变量也存储在栈内，所以优先取得局部变量的值
3. 当栈中不存在该变量名时，才选择去堆内存中对象下查找是否有该名字的变量

## 类类型参数
* 指方法的参数为类的对象
* 该方法的功能：用于改变对象的属性
* 类类型变量一定指向对象，或者为null，不能赋值为其他

## 匿名对象
* 形式：new className();
* 定义对象的简写格式
1. 使用方式
	1. 当对象对方法「只进行一次调用时」就可以简化成匿名对象
	2. 匿名对象可以作为「方法参数」传递

## (一) 基本数据类型参数传递
	```
		classDemo
		{
			public static void main(String[] args)
			{
				int x = 3;
				show(x);
				System.out.println("x=" + x);
			}
			public static void show (int x)
			{
				x = 4;
			}
		}
	```
	
* show()方法改变的是show代码段内的x值
* show()方法弹栈后对main代码段内的x值无影响
* 系统依然输出main代码段中的x值，为3

## (二) 引用数据类型参数传递
	```
		class Demo
		{
			int x = 3;
			public static void main(String[] args)
			{
				Demo d = new Demo();
				d.x = 9;
				show(d);
				System.out.println(d.x);
			}
			public static void show(Demo d)
			{
				d.x = 4;
			}
		}
	```
	
* 对象的数据域只要被改变，均为堆内存的数据被改变
	
## 封装
	```
		class Person
		{
			private int age; //封装属性
			
			public void setAge(int a)
			{
				age = a;
			}// 设置属性
			
			public int getAge()
			{
				return age;
			}// 获得属性
		}
	```

## 权限修饰符
1. private
	1. 只能用于修饰成员，不能修饰局部
	2. 私有的内容只在类中有效 
2. public
	* 被修饰后可以在类外访问
		
## 构造函数
 1. 一个类中如果没有定义过构造函数，该类中会有一个默认的空参数构造函数
 2. 如果在类中定义了指定的构造函数，那么类中的默认构造函数便不存在
 3. 构造函数允许重载，重载构造函数间参数列表不同
 	1. 参数个数
 	2. 参数类型
 	3. 参数顺序
 		* 参数个数、类型相同，参数顺序不同也构成重载
 4. 构造函数名通常首字母大写，容易区分
 5. 构造函数包含`return;`语句，只起结束函数的作用
 
## 什么时候定义构造函数？
1. 描述事物时，该事物已存在就具备一些内容，这些内容就定义在构造函数中

## 静态工具类，实现阻止类创建对象的方法
1. `private 构造函数名(){}`
2. 工具类的所有方法都是静态的，为了阻止其创建对象浪费堆内存空间，可以将构造函数私有化

## 文档注释导出-应用程序说明书
1. 格式
```
	程序整体
	/**
		建立一个用于操作数组的工具类
		其中包含了常见对数组操作的函数，如：最值、排序等
		@author Mark
		@version V1.0
	*/
	单个函数
	/**
		获取整型数组的最大值
		@param arr 接收一个元素为int类型的数组
		@return 该数组中的最大元素值
	*/
```

2. 如果把一个类文档化导出，该类必须是public类
	* 文档注释也只会提供出public方法信息，不提供private方法信息
3. javadoc 只会导出文档注释`/**...*/`，不会导出多行注释`/*...*/`
	

## 将数组以String形式全部打印
```
	public static String arrayToString(int[] arr)
	{
		String str = "[";
		
		for (int i = 0; i < arr.length; i++)
		{
			if(x!=arr.length-1)
				str = str + arr[x]+",";
			else
				str = str + arr[x]+"]";
		}
		
		return str;
	}
```

* 采用字符串相加的方式，将数组内容合并在一起

## this关键字
1. this调用变量	
	1. 问题：局部变量和成员变量重名

	2. 解决方法：`this.name = name;`
		1. `this.name`代表堆内存中的成员变量name
		2. `name`代表局部变量name
		3. 该动作将局部变量取得的值赋给成员变量
	
	3. 哪个对象调用了this所在的函数，this就代表了哪个对象  
2. this调用构造方法
	1. 关键字this可以用于在同一个类的构造方法中「调用另一个重载构造方法」
		```
			Person(String name)
			{
				this.name = name;
			}
			
			Person(String name,int age)
			{
				this(name); //此处调用的为上述构造方法
				this.age = age;
			}
		```	
		
		* 此处`this(args);`只能定义在构造函数的第一行，「初始化先执行」
		* 优势：提高代码复用率 
3. this 应用范围
	1. 在本类中用到本类的对象，通常用到this
		* 此时对象还没有被创建，this代表未被创建对象的位置
		 	```
		 		public boolean compare(Person p)
		 		{
		 			if(this.age == p.age)
		 				return true;
		 			else
		 				return false;
		 				
		 			// return this.age == p.age;
		 		}	
		 		
		 		p1.compare(p2);	
		 	```
 	
## 设计模式
 1. 单例设计模式
	 * 解决的问题： 可以保证一个类在内存中对象的唯一性
	 * 比如：多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性
	 
	 * 如何保证对象的唯一性？
	 	1. 不允许其它程序用new创建该类对象
	 	2. 在该类中创建一个本类实例
	 	3. 对外提供方法让其它程序可以获取该对象
	 	
	 * 实现步骤
	 	1. 私有化该类构造函数
	 	2. 通过new在本类内创建本类对象
	 	3. 定义一个public方法，将创建的对象返回
	 	```
	 		//方案1-饿汉式
	 		class Single
	 		{
	 			private static Single s = new Single();
	 			private Single(){}
	 			public static Single getInstance() 
	 			{
	 				return s;
	 			}
	 		}
	 	```
	 	
	 	* static修饰函数，以被类名调用
	 	* static修饰变量，以被static函数访问
	 	
	 	```
	 		//方案2-懒汉式
	 		class Single2
	 		{
	 			private static Single2 s = null;
	 			private Single2(){}
	 			public static Single2 getInstance()
	 			{
	 				if(s == null)
	 					s = new Single2();
	 				return s;
	 			}
	 		}
	 	```
	 	
	 	* 方案1与方案2 的区别
	 		1. 方案1：随着类的加载，对象就已经生成，开发常用
	 		2. 方案2：调用getInstance()函数，创建新对象
	 			* 是方案1的延迟加载形式，面试常用
	 			* 方案2被多线程并发访问时有安全隐患
	 			
## 继承
1. 格式
```
	class SonClass extends FatherClass
	{
		// 继承父类的全部方法
	}
```

2. Java支持单继承，不支持多继承
	* 单继承：一个子类只能有一个直接父类
	* 多继承：多个父类中有同名成员函数时，会产生调用的不确定性
		* 在Java中使用“多实现”的方式实现的
		* 对C++中的多继承机制进行了改良
3. Java支持多层继承

4. 子类和父类的变量名冲突时，子类变量有效
	* 当子类的变量和父类变量重名时，用super关键字区分父类
		* this代表一个本类对象的引用
		* super代表一个父类的空间
		
5. Java 中的所有类都是 Object 类的子类

## 什么时候用继承？
当类与类之间存在所属关系时，定义继承

所属关系：xxx 是 yyy 的一种	 

## 子父类中「成员函数」的特点
1. 函数的两个特性
	1. overload-重载：两函数函数名与返回值一致，参数列表不同
	2. override-子类重写父类函数：两函数函数名、返回值和参数列表完全一致	
	3. **重写注意事项**
		1. 子类方法重写父类方法时，子类方法权限必须大于等于父类权限
			* 权限顺序：public > (none) > private
		2. 静态子类重写静态父类，两者其中有一个不是静态都不通过编译
	4. **什么时候用重写操作？**
		* 当对一个类进行子类扩展时，子类需要保留父类的功能声明，但是要定义父类中该功能的特有内容时，使用「重写」实现
			1. 用继承的方式进行程序的版本升级，而不是修改源代码
			2. 保留父类原有功能，创建子类特有内容
				* 父类保留原有功能「用super调用原函数的方式」
		
## 子父类中「构造函数」的特点
1. 在子类构造对象时，发现：访问子类构造函数时，父类构造函数也运行 ？
	* 原因是：在子类构造函数中第一行有一个默认的隐式语句`super();`
		* `super();`调用的是父类中的「空参构造函数」
		* 父类中如没有空参数构造函数，会报错，需要用`super`明确调用
2. 构造函数不发生重写，也没有被继承过来，只能在子类中通过`super`访问
3. 子类的实例化过程，子类构造函数默认都会访问父类空参构造函数
	```
		SonClassName(args or not)
		{
			//隐式访问super();
			System.out.println("son's contents");
		}
	```
	
4. **为什么子类实例化的时候要访问父类的构造函数 ？**
	* 子类有可能用到父类的成员变量，因此要事先了解父类如何对该变量初始化的
	* 因此子类在构造对象时会事先访问父类构造函数，即在子类构造函数中加入了`super();`语句
	* 如果父类中没有定义空参数构造函数，那么子类的构造函数必须使用super语句明确调用
	
	* `super`语句必须定义在子类构造函数的第一行
		* 由于`super();`和`this();`都必须放在构造函数首行
		* 因此有`this();`后，该构造函数中就不存在`super()`
		* 但总会通过某个`this`访问到父类构造函数
	
	```
	/* 特殊例子 */
		Son()
		{
			//super();
		}
		
		Son(args)// 此构造函数中没有super();
		{
			this();
			//Son(args)的内容
		}
		
	```
	
	5. **父类初始化完毕，才执行子类显式初始化**
		* 先在子类中执行`super();`
		* `super();`弹栈后再执行子类中第一条`int sonx = 42;`
		* int sonx 初值值为 0
		
## 一个对象的实例化过程
`Person p = new Person();`

1. JVM读取指定路径下的Person.class文件，并加载进内存，并先加载Person的父类
2. 在堆内存中开辟空间分配地址
3. 并在对象空间中，对对象中的属性进行默认初始化 ***
4. 调用对应的构造函数初始化对象
5. 在构造函数首行，先调用`super();`
6. 父类初始化完毕后，在对子类的属性进行显式初始化 ***
7. 再对对象进行子类构造函数的特定初始化
8. 初始化完毕后，将地址值赋给引用变量

## final关键字 

 
## Java 数据库程序设计

 1. 关系型数据库系统
 	1. 关系结构
 		1. 每一行表示：相互关联的数据构成一行，称为元组
 		2. 每一列表示一个属性
 	
 	2. 完整性
 		1. 域约束：规定一个属性的允许值
 		2. 主键约束：
 			1. 超键：表格中所有属性对应值的集合
 			2. 键：最小单元
 			3. 候选键：除主键之外的其它最小单元
 		
 			* 主键：数据库设计者指定的候选键之一
 		3. 外键约束
 			1. 不同表格中的记录通过它们「共同属性」也是相互关联的
 			2. 共同属性即为外键
 			
 		* 数据库管理系统强制执行完整性约束
 	
 	3. 语言：
 		* SQL：结构化查询语言
 		
 
 2. SQL
